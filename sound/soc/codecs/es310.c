/*
 * es310.c  --  ES310 ALSA Soc Audio driver
 *
 * Copyright 2008-2010 Wolfson Microelectronics PLC.
 *
 * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * The download image for the ES310 will be requested as
 * 'es310_anc.bin' by default (overridable via platform data) at
 * runtime and is expected to be in flat binary format.  This is
 * generated by Wolfson configuration tools and includes
 * system-specific callibration information.  If supplied as a
 * sequence of ASCII-encoded hexidecimal bytes this can be converted
 * into a flat binary with a command such as this on the command line:
 *
 * perl -e 'while (<>) { s/[\r\n]+
 *                 < file  > es310_anc.bin
 */
/***********************************************************************/
/* Modified by                                                         */
/* (C) NEC CASIO Mobile Communications, Ltd. 2013                      */
/***********************************************************************/

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/firmware.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/debugfs.h>
#include <linux/slab.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/initval.h>
#include <sound/tlv.h>
#include <linux/input.h>	
#include <linux/types.h>


#include <linux/gpio.h>
#include <linux/regulator/consumer.h>
#include <sound/es310.h>


#include "es310.h"





#include "es310_hw.h"


#include "yda160.h"


#include <linux/msm_audio.h>
DEFINE_MUTEX(es310_dev_lock);



#define ES310_ACK_VAL(reg,val) (((reg&0xffff)<<16)|val)

#define ES310_BOOT_CMD 0x0001
#define ES310_BOOTACK_CMD 0x0101

#define ES310_SYNC_REG    0x8000
#define ES310_SYNC_BOOT_VAL 0x0000
#define ES310_SYNC_WAKEUP_VAL 0x0001

#define ES310_SYNC_ACK_VAL 0x80000000

#define ES310_SLEEP_REG   0x8010
#define ES310_SLEEP_REG_VAL 0x0001
#define ES310_SLEEP_ACK_VAL 0x80100001






#define ONETIME_WRITE_SIZE 0x2800

#define FEATURE_ES310_PATH_UPDATE 


#if defined(ES310_REQUEST_FIRMWARE)
#define ES310_FIRMWARE_NAME "es310_fw.bin"
#define ES310_FW_READ_ATTEMPTS 15
#define ES310_FW_READ_TIMEOUT 2000000
#endif











typedef enum {
    ES310_OFF, 
    ES310_CT,
    ES310_HHS,
	ES310_HHS_3POLE,
    ES310_DV,    
    ES310_WHS, 
    
	ES310_TTY_FULL,    
	ES310_TTY_HCO, 
	ES310_TTY_VCO, 
    
	
	
    ES310_CT_REC,
	ES310_HHS_REC, 
	ES310_HHS_3POLE_REC, 
    ES310_DV_REC,
    ES310_WHS_REC,	
    
    ES310_CT_VPOFF, 
    ES310_WHS_VPOFF, 
    ES310_VT, 
    MAX_FEATRUE
} es310_feature_type;


typedef enum {
    ES310_MIC_NONE,
    ES310_MIC_HANDSET,
    ES310_MIC_HEADSET,
	ES310_MIC_SPEAKER,
    ES310_MIC_BACK,    
    ES310_MIC_MAX
} es310_mic_type;

typedef enum {
    ES310_AMP_NONE,
    ES310_AMP_RECIVER,
    ES310_AMP_HEADSET,
	ES310_AMP_SPEAKER,
    ES310_AMP_MAX
} es310_amp_type;


#if defined(ES310_REQUEST_FIRMWARE)
struct es310_reg_s{
	unsigned short reg;
	unsigned short val;
};
















struct es310_reg_s modepath[MAX_FEATRUE]={
    {0x8031,0x0000},
	{0x8031,0x0000},
	{0x8031,0x0001},
	{0x8031,0x0002},
	{0x8031,0x0003},
	{0x8031,0x0004},
	{0x8031,0x0005},
	{0x8031,0x0006},
	{0x8031,0x0007},
	{0x8031,0x0008},
	{0x8031,0x0009},
	{0x8031,0x000A},
	{0x8031,0x000B},
	{0x8031,0x000C},
	{0x8031,0x0010}, 
	{0x8031,0x0011}, 
	{0x8031,0x000D}, 
};


#endif


enum es310_amp_state {
	AMP_FW_DOWNLOAD = 0,
	AMP_SLEEP = 1,
	AMP_WAKEUP = 2,
	AMP_OFF = 3,
};

struct es310_priv {
	struct i2c_client *i2c;

	int anc_download_size;
	char *anc_download;

	int mode_data_size;
	unsigned short *mode_data;
	
	struct regulator *supply;
	int reset_gpio;
	int wakeup_gpio;
	int mic1_gpio;
	int mic2_gpio;	
	int (*aud_clk)(int on);  
	
	struct mutex	mutext_lock;
	unsigned char rxdata[2];

	struct delayed_work firmware_dwork;
	const struct firmware *es310_fw;	

#if defined(FEATURE_ES310_PATH_UPDATE)
    int amp_cur_path; 

    int amp_cur_state; 
#endif

	int yda160_amp_cur_path; 
};


static struct i2c_client *es310_i2c;
static int es310_mode_control; 
static int es310_set_feature(es310_feature_type feature);
static void es310_mic_control(int ctl);

static int es310_sync(unsigned int reg,unsigned int val);



static int es310_mic_select_input(int mic_select_cmd); 
int es310_mic_ctrl(char mic_bias_cmd);  



static int es310_i2c_write_reg(struct i2c_client *i2c, unsigned short reg_address)
{
	int ret;
	unsigned char txdata[2];
	struct es310_priv *es310 = i2c_get_clientdata(i2c);

	mutex_lock(&es310->mutext_lock);
	txdata[0] = (reg_address >> 8) & 0xFF;
	txdata[1] = reg_address & 0xFF;	

	ret = i2c_master_send(i2c, txdata, 2);
	mutex_unlock(&es310->mutext_lock);

	if (ret != 2) pr_err("%s fail addr 0x%x ret %d\n", __func__, reg_address, ret);
	

	if (ret == 2)
		return 0;
	if (ret < 0)
		return ret;
	else
		return -EIO;
}


static int es310_i2c_write_reg_16(struct i2c_client *i2c, unsigned short reg_address,unsigned short value)
{
	struct es310_priv *es310 = i2c_get_clientdata(i2c);
	int ret;
	unsigned char txdata[4];

	mutex_lock(&es310->mutext_lock);
	txdata[0] = (reg_address >> 8) & 0xFF;
	txdata[1] = reg_address & 0xFF;
	txdata[2] = (value >> 8) & 0xFF;
	txdata[3] = value & 0xFF;

	ret = i2c_master_send(i2c, txdata, 4);
	mutex_unlock(&es310->mutext_lock);

	if (ret != 4) pr_err("%s fail addr 0x%x value %d ret %d\n", __func__, reg_address, value, ret);

	if (ret == 4)
		return 0;
	if (ret < 0)
		return ret;
	else
		return -EIO;
}

































static int es310_i2c_read_reg_16(struct i2c_client *i2c,unsigned short *val)
{
	struct es310_priv *es310 = i2c_get_clientdata(i2c);
	int ret;
	unsigned char rxdata[2]={0,};

	mutex_lock(&es310->mutext_lock);
	ret = i2c_master_recv(i2c, rxdata, 2);
	mutex_unlock(&es310->mutext_lock);	

	*val = (rxdata[0] << 8) | rxdata[1];

	if (ret != 2) pr_err("%s fail ret %d\n", __func__, ret);
	pr_debug("%s: val 0x%x ret %d\n", __func__,*val,ret);

	
	


	if (ret == 2)
		return 0;
	if (ret < 0)
		return ret;
	else
		return -EIO;	
	

}


static int es310_i2c_read_reg_32(struct i2c_client *i2c,unsigned int *val)
{
	struct es310_priv *es310 = i2c_get_clientdata(i2c);
	int ret;
	unsigned char rxdata[4]={0,};

	mutex_lock(&es310->mutext_lock);
	ret = i2c_master_recv(i2c, rxdata, 4);
	mutex_unlock(&es310->mutext_lock);	

	*val = (rxdata[0] << 24) | (rxdata[1] << 16) | (rxdata[2] << 8) | rxdata[3];

	if (ret != 4) pr_err("%s fail ret %d\n", __func__, ret);
	

	
	


	if (ret == 4)
		return 0;
	if (ret < 0)
		return ret;
	else
		return -EIO;	
	

}

























#if !defined(ES310_REQUEST_FIRMWARE)
static int es310_i2c_write_ndata(struct i2c_client *i2c) 
{
    int ret;
	int count=0;
	int index_16,total_cmd;

	struct es310_priv *es310 = i2c_get_clientdata(i2c);
	
    
	index_16 = es310->mode_data_size/sizeof(unsigned short);
    total_cmd = index_16/2;
	
	pr_debug("%s index:%d total cmd:%d\n", __func__,index_16,total_cmd);


    do{
	   ret = es310_i2c_write_reg_16(i2c,es310->mode_data[count*2],es310->mode_data[(count*2)+1]);
	   
	   
	   count++;
   	}while(count<total_cmd);










	return 0;

}
#endif

static int get_mode_control(struct snd_kcontrol *kcontrol,
	struct snd_ctl_elem_value *ucontrol)
{
	pr_debug("%s: mode_control = %d", __func__, es310_mode_control);
	ucontrol->value.integer.value[0] = es310_mode_control;
	return 0;
}

static int set_mode_control(struct snd_kcontrol *kcontrol,
	struct snd_ctl_elem_value *ucontrol)
{
	

	es310_mode_control = ucontrol->value.integer.value[0];

	pr_debug("%s() mode %d\n", __func__,es310_mode_control);


    
	es310_set_feature(es310_mode_control); 
	
	
	return 1;
}

static int es310_mic_event(struct snd_soc_dapm_widget *w,
	struct snd_kcontrol *k, int event)
{
	pr_debug("%s() %x\n", __func__, SND_SOC_DAPM_EVENT_ON(event));

	if (SND_SOC_DAPM_EVENT_ON(event)) {
		if(!strncmp(w->name, "Handset Mic", 12)) {			
			pr_debug("%s() %x\n", __func__,1);

			
			
            
			
			
			
			es310_mic_control(1); 
			
			
		}
		else {
			pr_err("%s() Invalid Amp Widget = %s\n",__func__, w->name);
			return -EINVAL;
		}
		
	} else if(SND_SOC_DAPM_EVENT_OFF(event)) {
		if(!strncmp(w->name, "Handset Mic", 12)) {			
			pr_debug("%s() %x\n", __func__,0);

			es310_mic_control(0); 

			
			
            
			
			
		}		
		else {
			pr_err("%s() Invalid Amp Widget = %s\n",__func__, w->name);
			return -EINVAL;
		}
	}
	return 0;
}



































static const struct snd_soc_dapm_widget es310_dapm_widgets[] = {







	
	SND_SOC_DAPM_SPK("ES310 Amp", NULL), 
	SND_SOC_DAPM_MIC("Handset Mic", es310_mic_event),
	
};

static const struct snd_soc_dapm_route es310_audio_map[] = {
	{"ES310 Amp", NULL, "LINEOUT1"}, 
	

	
	{"AMIC5", NULL, "MIC BIAS1 Internal1"}, 
	{"MIC BIAS1 Internal1", NULL, "Handset Mic"}, 

	
	{"AMIC5", NULL, "MIC BIAS2 Internal1"}, 
	{"MIC BIAS2 Internal1", NULL, "Handset Mic"}, 
};


static const char *es310_mode_ctl[] = {
  "OFF",
  "CT", 
  "HHS", 
  "3POLE",
  "DV", 
  "WHS", 
  
  "FULL_TTY", 
  "HCO_TTY", 
  "VCO_TTY", 
  


  "REC_CT", 
  "REC_HHS", 
  "REC_3POLE", 
  "REC_DV", 
  "REC_WHS", 

  "VPOFF_CT", 
  "VPOFF_WHS", 
  "VT", 
}; 

static const struct soc_enum es310_enum[] = {
	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(es310_mode_ctl),es310_mode_ctl), 
};

static const struct snd_kcontrol_new es310_controls[] = {
	SOC_ENUM_EXT("ES310 mode control", es310_enum[0], get_mode_control, 
		set_mode_control),
};





int es310_add_controls(struct snd_soc_codec *codec)
{
	struct snd_soc_dapm_context *dapm = &codec->dapm;
	int ret;

	if (!es310_i2c) {
		pr_err("ES310 not yet probed\n");
		return -ENODEV;
	}

	ret = snd_soc_dapm_new_controls(dapm, es310_dapm_widgets,
					ARRAY_SIZE(es310_dapm_widgets));
	if (ret < 0)
		return ret;

	ret = snd_soc_dapm_add_routes(dapm, es310_audio_map, ARRAY_SIZE(es310_audio_map));
	if (ret < 0)
		return ret;

	return snd_soc_add_codec_controls(codec, es310_controls,
			ARRAY_SIZE(es310_controls));





}
EXPORT_SYMBOL_GPL(es310_add_controls);



static void es310_mic_control(int ctl)
{
  struct es310_priv *es310 = i2c_get_clientdata(es310_i2c);

  pr_debug("%s start es310_mode_control %d ctl %d!!!\n", __func__,es310_mode_control,ctl);

  switch(es310_mode_control)
	{
	  case ES310_OFF:
	      break;	

      case ES310_TTY_HCO: 
	  case ES310_TTY_FULL:      	      
	  case ES310_WHS:
		  if(ctl==1){
			gpio_set_value_cansleep(es310->mic1_gpio, 0);	   
			gpio_set_value_cansleep(es310->mic2_gpio, 1);		
		  }

		  break;

      case ES310_TTY_VCO: 
	  case ES310_CT:
		  if(ctl==1){
			gpio_set_value_cansleep(es310->mic1_gpio, 0);	   
			gpio_set_value_cansleep(es310->mic2_gpio, 0);		
		  }

		  break;

      case ES310_DV:
	  case ES310_HHS:
	  case ES310_VT: 
			if(ctl==1){
			  gpio_set_value_cansleep(es310->mic1_gpio, 1); 	 
			  gpio_set_value_cansleep(es310->mic2_gpio, 0); 	  
			}
		
			break;

	

		case ES310_WHS_REC:
			if(ctl==1){
			  gpio_set_value_cansleep(es310->mic1_gpio, 0); 	 
			  gpio_set_value_cansleep(es310->mic2_gpio, 1); 	  
			}

			break;

		case ES310_CT_REC:
			if(ctl==1){
			  gpio_set_value_cansleep(es310->mic1_gpio, 0); 	 
			  gpio_set_value_cansleep(es310->mic2_gpio, 0); 	  
			}
			break;

		case ES310_DV_REC:
		case ES310_HHS_REC:
			  if(ctl==1){
				gpio_set_value_cansleep(es310->mic1_gpio, 1);	   
				gpio_set_value_cansleep(es310->mic2_gpio, 0);		
			  }
		  
			  break;

        case ES310_HHS_3POLE:
        case ES310_HHS_3POLE_REC:
			if(ctl==1){
			  gpio_set_value_cansleep(es310->mic1_gpio, 0); 	 
			  gpio_set_value_cansleep(es310->mic2_gpio, 0); 	  
			}
			break;



	}

  	
}



static void es310_wakeup_control(int ctl)
{
  struct es310_priv *es310 = i2c_get_clientdata(es310_i2c);

  pr_debug("%s start wakeup_gpio %d ctl %d!!!\n", __func__,es310->wakeup_gpio,ctl);

  if(ctl==1){
    gpio_set_value_cansleep(es310->wakeup_gpio, 1);      
  }
  else{
    gpio_set_value_cansleep(es310->wakeup_gpio, 0);  
    
  }
  	
}

static void es310_reset_control(int ctl)
{
  struct es310_priv *es310 = i2c_get_clientdata(es310_i2c);

  pr_debug("%s start reset_gpio %d ctl %d!!!\n", __func__,es310->reset_gpio,ctl);

  if(ctl==1){
    gpio_set_value_cansleep(es310->reset_gpio, 1);  
  }
  else{
    gpio_set_value_cansleep(es310->reset_gpio, 0);  
  }  	
}

static int es310_boot_seq(int ctl)
{
	
	struct i2c_client *client = es310_i2c;
	unsigned short buf = 0;
	int count=0;
	
	
	int ret;
	
	pr_debug("%s start !!!\n", __func__);

    es310_wakeup_control(1);
    es310_reset_control(1); 
    msleep(10); 
    
	es310_reset_control(0);
	msleep(3);
	es310_reset_control(1);

	msleep(1);
	es310_wakeup_control(0);

    msleep(70);
	
	es310_wakeup_control(1); 

	
	
    
    es310_i2c_write_reg(client,ES310_BOOT_CMD);    
    msleep(3);    

    do{
	  count++;
	  msleep(1);
	  ret = es310_i2c_read_reg_16(client,&buf);	
   	}while((buf != ES310_BOOTACK_CMD)&&(count<100));

	
	
	
    if(buf != ES310_BOOTACK_CMD)
    {
		pr_debug("%s Read Boot Ack failed\n", __func__);
		return -EINVAL;
    }
    pr_debug("%s Read Boot Ack success\n", __func__);

    return 0;
}



#if defined(ES310_REQUEST_FIRMWARE)

#if defined(FEATURE_ES310_PATH_UPDATE)

static int es310_amp_sleep(void)
{
    struct i2c_client *client = es310_i2c;
    struct es310_priv *es310 = i2c_get_clientdata(client);
    int ret;
	
	unsigned int synAck = 0;
	
    
	pr_debug("%s start\n", __func__);

	

	

	if(es310->amp_cur_state == AMP_SLEEP){
	   pr_debug("es310 current state sleep\n");
	   return 0;
	}	

	ret = es310_i2c_write_reg_16(client,ES310_SLEEP_REG,ES310_SLEEP_REG_VAL);


	msleep(20);












    if (ret != 0) {
       pr_debug("es310 sleep fail\n");
       return 0;
    }
    
    es310->amp_cur_state = AMP_SLEEP;
    
    pr_debug("%s sync ack 0x%x ret %d \n",__func__,synAck,ret);	

    return 0;
    





















    
}


static int es310_amp_wakeup(void)
{
    struct i2c_client *client = es310_i2c;
    struct es310_priv *es310 = i2c_get_clientdata(client);
    int ret;
	
	
	
    
	pr_debug("%s start\n", __func__);

	

	

	if(es310->amp_cur_state == AMP_WAKEUP){
	   pr_debug("es310 current state wakeup\n");
	   return 0;
	}	

	es310_wakeup_control(1);
	es310_wakeup_control(0);

	msleep(30);
		
	ret = es310_sync(ES310_SYNC_REG,ES310_SYNC_WAKEUP_VAL);
      
	es310_wakeup_control(1);
	
	
		
	if (ret != 0) {
	   pr_debug("es310 wakeup fail\n");
	   return 0;
	}

	es310->amp_cur_state = AMP_WAKEUP;

	pr_debug("%s ret %d \n",__func__,ret);	
    
    return 0;
}


static int es310_amp_set_device(es310_feature_type feature)
{
    struct i2c_client *client = es310_i2c;
    struct es310_priv *es310 = i2c_get_clientdata(client);
    int amp_cur_path = es310->amp_cur_path;

    pr_debug("%s start curpath %d feature %d\n", __func__,amp_cur_path,feature);

	
    if(amp_cur_path == feature){
        pr_debug("es310 same path\n");
        return 0;
    }

    
    switch(feature)
    {
		case ES310_CT:
		case ES310_HHS:
		case ES310_HHS_3POLE:
		case ES310_DV:
		case ES310_WHS:
		case ES310_TTY_FULL:
		case ES310_TTY_HCO:
		case ES310_TTY_VCO: 
		case ES310_CT_REC:
		case ES310_HHS_REC:
		case ES310_HHS_3POLE_REC:
		case ES310_DV_REC:
		case ES310_WHS_REC:
		case ES310_CT_VPOFF: 
    	case ES310_WHS_VPOFF: 
    	case ES310_VT: 




    		es310_amp_wakeup();
		  
          es310_i2c_write_reg_16(client,modepath[feature].reg,modepath[feature].val);
          es310->amp_cur_path = feature;

		  
		  if(feature == ES310_WHS_VPOFF) {
		  	char select_mic_bias_cmd = 0x10; 
		  	es310_mic_select_input(ES310_MIC_BACK);
			es310_mic_ctrl(select_mic_bias_cmd);
		  }
		  
		  
		  break;

		case ES310_OFF:
          es310_amp_sleep();
          es310->amp_cur_path = feature;




		  break;
		  
		default:
		  break;

    }

    return 0;

}



















































































































































static int es310_set_feature(es310_feature_type feature)
{
    
    
    
	pr_debug("%s start\n",__func__);

	es310_amp_set_device(feature);
	

	return 0;
}

#else
static int es310_set_feature(es310_feature_type feature)
{
    struct i2c_client *client = es310_i2c;
    
    
    
    
	pr_debug("%s start feature %d\n", __func__,feature);

	
	es310_i2c_write_reg_16(client,modepath[feature].reg,modepath[feature].val); 

	switch(feature)
	{
	    case ES310_OFF:







			break;

        case ES310_TTY_VCO: 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
			yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
			break;


	    case ES310_TTY_FULL:

			yda160_amp_set_path(YDA160_OFF_PATH,1);
			yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
			break;
			
		case ES310_TTY_HCO: 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
			yda160_amp_set_path(YDA160_RECV_OUT_PATH,1);
			break;

		    break;
              
		    
		case ES310_CT:	

			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_RECV_OUT_PATH,1);
            
		    break;
			
		case ES310_DV:


			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_SPMIXER_MIN_PATH,1);
            break;
            
		case ES310_HHS:


			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_SPMIXER_MIN_PATH,1);		
		    break;
		    
		case ES310_WHS:


			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
		    break;

       

		case ES310_CT_REC:	


			
            
            
		    break;
			
		case ES310_DV_REC:


			
            
            break;
            
		case ES310_HHS_REC:


			
            
		    break;
		    
		case ES310_WHS_REC:


			
            
		    break;
 
	 	  case ES310_HHS_3POLE:

	 	  
	 		  yda160_amp_set_path(YDA160_OFF_PATH,1);
	 		  yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
	 		  break;
	 
	 	  case ES310_HHS_3POLE_REC:

	 	  
	 		  
	 		  
	 		  break;
  

		default:
			break;
	}

	return 0;

}
#endif

#else
static int es310_set_feature(es310_feature_type feature)
{
    struct i2c_client *client = es310_i2c;
    struct es310_priv *es310 = i2c_get_clientdata(client);
    
    
    
	pr_debug("%s start feature %d\n", __func__,feature);

	switch(feature)
	{
	    case ES310_OFF:







			break;

        case ES310_TTY_VCO: 
	    case ES310_TTY_FULL:
			es310->mode_data_size = sizeof(ES310_MODE_OFF);
			es310->mode_data = ES310_MODE_OFF;			
            es310_i2c_write_ndata(client); 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
			yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
			break;
			
		case ES310_TTY_HCO: 
			es310->mode_data_size = sizeof(ES310_MODE_OFF);
			es310->mode_data = ES310_MODE_OFF;			
            es310_i2c_write_ndata(client); 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
			yda160_amp_set_path(YDA160_RECV_OUT_PATH,1);
			break;

		    break;
              
		    
		case ES310_CT:	
			es310->mode_data_size = sizeof(ES310_MODE_CT);
			es310->mode_data = ES310_MODE_CT;			
            es310_i2c_write_ndata(client); 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_RECV_OUT_PATH,1);
            
		    break;
			
		case ES310_DV:
			es310->mode_data_size = sizeof(ES310_MODE_DV);
			es310->mode_data = ES310_MODE_DV;			
            es310_i2c_write_ndata(client); 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_SPMIXER_MIN_PATH,1);
            break;
            
		case ES310_HHS:
			es310->mode_data_size = sizeof(ES310_MODE_HHS);
			es310->mode_data = ES310_MODE_HHS;			
            es310_i2c_write_ndata(client); 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_SPMIXER_MIN_PATH,1);		
		    break;
		    
		case ES310_WHS:
			es310->mode_data_size = sizeof(ES310_MODE_WHS);
			es310->mode_data = ES310_MODE_WHS;			
            es310_i2c_write_ndata(client); 

			yda160_amp_set_path(YDA160_OFF_PATH,1);
            yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
		    break;

       
       #if (ES310_FIRMWARE_REV>=VER(9,2)) 
		case ES310_CT_REC:	
			es310->mode_data_size = sizeof(ES310_MODE_CT_REC);
			es310->mode_data = ES310_MODE_CT_REC;			
            es310_i2c_write_ndata(client); 

			
            
            
		    break;
			
		case ES310_DV_REC:
			es310->mode_data_size = sizeof(ES310_MODE_DV_REC);
			es310->mode_data = ES310_MODE_DV_REC;			
            es310_i2c_write_ndata(client); 

			
            
            break;
            
		case ES310_HHS_REC:
			es310->mode_data_size = sizeof(ES310_MODE_HHS_REC);
			es310->mode_data = ES310_MODE_HHS_REC;			
            es310_i2c_write_ndata(client); 

			
            
		    break;
		    
		case ES310_WHS_REC:
			es310->mode_data_size = sizeof(ES310_MODE_WHS_REC);
			es310->mode_data = ES310_MODE_WHS_REC;			
            es310_i2c_write_ndata(client); 

			
            
		    break;
 
	 	  case ES310_HHS_3POLE:
	 		  es310->mode_data_size = sizeof(ES310_MODE_3POLE);
	 		  es310->mode_data = ES310_MODE_3POLE;		  
	 		  es310_i2c_write_ndata(client); 
	 	  
	 		  yda160_amp_set_path(YDA160_OFF_PATH,1);
	 		  yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
	 		  break;
	 
	 	  case ES310_HHS_3POLE_REC:
	 		  es310->mode_data_size = sizeof(ES310_MODE_3POLE_REC);
	 		  es310->mode_data = ES310_MODE_3POLE_REC;		  
	 		  es310_i2c_write_ndata(client); 
	 	  
	 		  
	 		  
	 		  break;
      #endif 

		default:
			break;
	}

	return 0;

}
#endif



static int es310_firmware_download(void)
{
    struct i2c_client *client = es310_i2c;
    struct es310_priv *es310 = i2c_get_clientdata(client);
    int ret=0;
    char *anc_download;
    int download_size=0;



	unsigned char i=0;
	int count=0,pos_next=0;
	int remain=0;


	pr_debug("%s start\n", __func__);

















































































	anc_download = es310->anc_download;
	download_size = es310->anc_download_size;

	count = download_size/ONETIME_WRITE_SIZE;
    remain = download_size%ONETIME_WRITE_SIZE;

    pr_debug("Downloading %d bytes count %d remain %d\n",es310->anc_download_size,count,remain);
    
    mutex_lock(&es310->mutext_lock);

    for(i=0;i<count;i++)
    {    	
		
		ret = i2c_master_send(client,anc_download+pos_next,ONETIME_WRITE_SIZE);
		pos_next += ret;
		
    }


    
    
    if(remain)
    {
		ret = i2c_master_send(client,anc_download+pos_next,remain);
        pos_next += ret;
        
    }
	mutex_unlock(&es310->mutext_lock);		      

	if (pos_next != es310->anc_download_size) {
		dev_err(&client->dev, "i2c_transfer() failed, %d != %d\n",
			ret, es310->anc_download_size);
		return -EIO;
	}

	es310->amp_cur_state = AMP_FW_DOWNLOAD;


	pr_debug("Download complete\n");

    
    return 0;
}
































static int es310_sync(unsigned int reg,unsigned int val)
{
	struct i2c_client *client = es310_i2c;
	unsigned int synAck,synVal;
	char count=0;

	int ret;
	
	pr_debug("%s start !!!\n", __func__);

	synVal = ES310_ACK_VAL(reg,val);

	ret = es310_i2c_write_reg_16(client,reg,val);
	
	
	do{
		count++;
		msleep(1);
	    ret = es310_i2c_read_reg_32(client,&synAck);
	}while((synAck != synVal)&&(count<20));

	







    pr_debug("%s sync ack 0x%x ret %d \n",__func__,synAck,ret);	
    return ret;

}




static int es310_sleep(void)
{
    struct i2c_client *client = es310_i2c;
    struct es310_priv *es310 = i2c_get_clientdata(client);
    
	
	
	
    
	pr_debug("%s start\n", __func__);

	if(es310->amp_cur_state == AMP_SLEEP){
	   pr_debug("es310 current state sleep\n");
	   return 0;
	}

	es310_i2c_write_reg_16(client,ES310_SLEEP_REG,ES310_SLEEP_REG_VAL);

	es310->amp_cur_state = AMP_SLEEP;






















    
    return 0;
}


static int es310_wakeup(void)
{
    struct i2c_client *client = es310_i2c;
    struct es310_priv *es310 = i2c_get_clientdata(client);
    int ret;
	
	
	
    
	pr_debug("%s start\n", __func__);

	if(es310->amp_cur_state == AMP_WAKEUP){
	   pr_debug("es310 current state wakeup\n");
	   return 0;
	}

	es310_wakeup_control(1);
	es310_wakeup_control(0);

	msleep(30);
		
	ret = es310_sync(ES310_SYNC_REG,ES310_SYNC_WAKEUP_VAL);
      
	es310_wakeup_control(1);
	
	
		








    es310->amp_cur_state = AMP_WAKEUP;
    
	pr_debug("%s ret %d \n",__func__,ret);	
    
    return 0;
}




#if defined(ES310_REQUEST_FIRMWARE)
static void es310_fw_read(struct work_struct *work)
{
	struct delayed_work *dwork;
	struct es310_priv *es310; 
	const struct firmware *fw;
	int ret = -1, retry = 0;

	
    pr_debug("%s start \n",__func__);

	dwork = to_delayed_work(work);
	es310 = container_of(dwork, struct es310_priv,firmware_dwork);

	while (retry < ES310_FW_READ_ATTEMPTS) {
		retry++;
		pr_info("%s:Attempt %d to request ES310 firmware\n",
			__func__, retry);
		ret = request_firmware(&fw, ES310_FIRMWARE_NAME,&es310->i2c->dev);

		if (ret != 0) {
			usleep_range(ES310_FW_READ_TIMEOUT,
					ES310_FW_READ_TIMEOUT);
		} else {
			pr_info("%s: ES310 Firmware read succesful\n", __func__);
			break;
		}
	}

	if (ret != 0) {
		pr_err("%s: Cannot load ES310 firmware use default cal\n",
			__func__);
		
	}else{ 

    pr_debug("%s fw_size %d \n",__func__,fw->size);

	es310->anc_download_size = fw->size;
	es310->anc_download = kmalloc(es310->anc_download_size, GFP_KERNEL);
	if (es310->anc_download == NULL) {
		dev_err(&es310->i2c->dev, "Out of memory\n");
		ret = -ENOMEM;
		
	}
	
	memcpy(es310->anc_download, fw->data, fw->size);
	
	release_firmware(fw);

	es310_firmware_download();

	kfree(es310->anc_download);

    msleep(120);
	ret = es310_sync(ES310_SYNC_REG,ES310_SYNC_BOOT_VAL);
	}

    pr_debug("%s end \n",__func__);





}
#endif

static int __devinit es310_i2c_probe(struct i2c_client *client,
				      const struct i2c_device_id *i2c_id)
{
    struct device *dev;
	struct es310_priv *es310; 
	struct es310_platform_data *pdata; 
	
	
	int ret;
	

    pr_debug("%s start !!!\n", __func__);
	pr_debug("%s:%s:0x%02x:%s\n", client->adapter->name, client->name, client->addr, i2c_id->name);

	dev = &client->dev;

    
	if (client->dev.platform_data == NULL) {
		
		
		return -ENODEV;
	}
	
	if (es310_i2c) {
		pr_debug("%s Another es310 is already registered\n", __func__);
		return -EINVAL;
	}

    
	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		pr_debug("%s i2c_check_functionality failed\n", __func__);
		return -EINVAL;
	}
	
	pr_debug("%s i2c_check_functionality success\n", __func__);

	es310_i2c = client;

    
	es310 = kzalloc(sizeof(struct es310_priv), GFP_KERNEL);
	if (es310 == NULL) {
		pr_debug("%s Unable to allocate private data\n", __func__);
		return -ENOMEM;
	}
    i2c_set_clientdata(es310_i2c, es310);
	
	
	pdata = client->dev.platform_data;
	es310->wakeup_gpio = pdata->wakeup_gpio;
	es310->reset_gpio = pdata->reset_gpio;
	es310->mic1_gpio = pdata->mic1_gpio;
	es310->mic2_gpio = pdata->mic2_gpio;
	es310->aud_clk = pdata->aud_clk; 

#if defined(FEATURE_ES310_PATH_UPDATE)
    es310->amp_cur_path = ES310_OFF;
    es310->amp_cur_state = AMP_OFF;
#endif

	es310->yda160_amp_cur_path = YDA160_OFF_PATH; 

#if defined(ES310_REQUEST_FIRMWARE)
    es310->i2c = client;
	INIT_DELAYED_WORK(&es310->firmware_dwork, es310_fw_read);
	#endif

    mutex_init(&es310->mutext_lock);

	
	ret = pdata->dev_setup(1);
	if(ret != 0)
	{
		pr_debug("%s Unable to setup gpio/power\n", __func__);	
		goto err_fw;
	}
	pdata->power_on(1);


	
	
    ret = es310_boot_seq(1);
    if (ret != 0) {
		dev_err(&client->dev,
			"Failed to es310_boot_seq : %d\n", ret);
		goto err_fw;
	}	

#if !defined(ES310_REQUEST_FIRMWARE)
   pdata->read_fw_bin = false;
#endif


	if(!pdata->read_fw_bin){



		 es310->anc_download_size = sizeof(es310_firmwareimage);
		 es310->anc_download = es310_firmwareimage;

		 if (es310->anc_download == NULL) {
			 dev_err(&client->dev, "Out of memory\n");
			 ret = -ENOMEM;
			 goto err_fw;
		 }
		 
		 ret = es310_firmware_download();
		 if (ret != 0) {
			 dev_err(&client->dev, "Failed to download firmare\n");
			 goto err_fw;
		 }
		 msleep(120);
	

		 ret = es310_sync(ES310_SYNC_REG,ES310_SYNC_BOOT_VAL);
		 if(ret != 0)
		 {
		   ; 
		   pr_debug("%s Sync ack fail %d\n",__func__,ret);
		   return -EIO;
		 }
		 
	



















	
	 }else{

#if defined(ES310_REQUEST_FIRMWARE)
		schedule_delayed_work(&es310->firmware_dwork,
					  usecs_to_jiffies(ES310_FW_READ_TIMEOUT));
	#endif
	 }

	

	pr_debug("%s end !!!\n", __func__);

	return 0;


err_fw:
	kfree(es310);
	i2c_set_clientdata(es310_i2c, NULL);
	es310_i2c = NULL;






	return ret;
}


static __devexit int es310_i2c_remove(struct i2c_client *client)
{
	struct es310_priv *es310 = i2c_get_clientdata(client);

	pr_debug("%s es310_i2c_remove !!!\n", __func__);

	
	

	if (es310->reset_gpio >= 0)
		gpio_free(es310->reset_gpio);
	if (es310->wakeup_gpio >= 0)
		gpio_free(es310->wakeup_gpio);
	if (es310->mic1_gpio >= 0)
		gpio_free(es310->mic1_gpio);
	if (es310->mic2_gpio >= 0)
		gpio_free(es310->mic1_gpio);

	regulator_put(es310->supply);

	es310_i2c = NULL;
	kfree(es310->anc_download);
	kfree(es310);

	return 0;
}

static void es310_i2c_shutdown(struct i2c_client *i2c)
{
	

	pr_debug("%s es310_i2c_shutdown !!!\n", __func__);

	
}


static int es310_i2c_suspend(struct device *dev)
{

	struct i2c_client *i2c = to_i2c_client(dev);
	struct es310_priv *es310 = dev_get_drvdata(&i2c->dev);

	pr_debug("%s es310_i2c_suspend !!!\n", __func__);



	es310_sleep();


    msleep(20);
    
    es310->aud_clk(0);  

	

	return 0;
}

static int es310_i2c_resume(struct device *dev)
{

	struct i2c_client *i2c = to_i2c_client(dev);
	struct es310_priv *es310 = dev_get_drvdata(&i2c->dev);

    pr_debug("%s es310_i2c_resume !!!\n", __func__);

	es310->aud_clk(1);  

	msleep(20);



    es310_wakeup();

	

	return 0;
}


static SIMPLE_DEV_PM_OPS(es310_pm, es310_i2c_suspend, es310_i2c_resume);

static const struct i2c_device_id es310_i2c_id[] = {
	{ "audience_es310", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, es310_i2c_id);

static struct i2c_driver es310_i2c_driver = {
	.driver = {
		.name = "audience_es310",
		.owner = THIS_MODULE,
		.pm = &es310_pm,
	},
	.probe = es310_i2c_probe,
	.remove = __devexit_p(es310_i2c_remove),
	.shutdown = es310_i2c_shutdown,
	.id_table = es310_i2c_id,
};


int es310_mic_ctrl(char mic_bias_cmd)   
{
    int ret=0, ACK=0;
    struct i2c_client *client = es310_i2c;

    pr_debug("%s - june\n", __func__);
    switch( mic_bias_cmd )
    {
    case 0x00 :
        pr_debug("%s : BIAS OFF - june\n", __func__);

        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParmID, MIC0_BIAS_PARAMID);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }

        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParm, MIC_BIAS_DISABLE);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }


        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParmID, MIC1_BIAS_PARAMID);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }

        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParm, MIC_BIAS_DISABLE);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }
        break;

    case 0x01 :
        pr_debug("%s : MIC1 BIAS ON - june\n", __func__);

        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParmID, MIC0_BIAS_PARAMID);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }

        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParm, MIC_BIAS_ENABLE);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }
        break;

    case 0x10 :
        pr_debug("%s : MIC2 BIAS ON - june\n", __func__);

        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParmID, MIC1_BIAS_PARAMID);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }

        
        ret = es310_i2c_write_reg_16(client, es310_A200_msg_SetDeviceParm, MIC_BIAS_ENABLE);
        if(ret != 0)
        {
            pr_debug("%s : write reg_addr error(%d) - june\n", __func__, ret);
            return 1;
        }

        
        ret = es310_i2c_read_reg_32(client, &ACK);
        if(ret != 0)
        {
            pr_debug("%s : reg_addr ACK error (ret=%d  /  ACK=%d) - june\n", __func__, ret, ACK);
            return 1;
        }
        break;

    default :
        pr_debug("%s : command error - june\n", __func__);
        return 1;
    }
    return 0;
}

static int es310_mic_select_input(int mic_select_cmd)   
{
	struct es310_priv *es310 = i2c_get_clientdata(es310_i2c);

	pr_debug("es310_mic_select_input. mic_select_cmd=%d\n", mic_select_cmd);
    switch( mic_select_cmd )
    {
		case ES310_MIC_HANDSET :
		case ES310_MIC_BACK :
			gpio_set_value_cansleep(es310->mic1_gpio, 0);	   
			gpio_set_value_cansleep(es310->mic2_gpio, 0);	
			break;
			
		case ES310_MIC_HEADSET :
			gpio_set_value_cansleep(es310->mic1_gpio, 0);	   
			gpio_set_value_cansleep(es310->mic2_gpio, 1);
			break;
			
		case ES310_MIC_SPEAKER :
			gpio_set_value_cansleep(es310->mic1_gpio, 1); 	 
			gpio_set_value_cansleep(es310->mic2_gpio, 0); 
			break;						
    }

	return 0;
}

static int es310_amp_select_output(int amp_select_cmd) 
{
	pr_debug("es310_amp_select_output. amp_select_cmd=%d\n", amp_select_cmd);
    switch( amp_select_cmd )
    {
		case ES310_AMP_RECIVER :
			yda160_amp_set_path(YDA160_RECV_OUT_PATH,1);
			break;
		case ES310_AMP_HEADSET :
			yda160_amp_set_path(YDA160_HPMIXER_MIN_PATH,1);
			break;
		case ES310_AMP_SPEAKER :
			yda160_amp_set_path(YDA160_SPMIXER_MIN_PATH,1); 
			break;					
    }

	return 0;
}


static int es310_dev_open(struct inode *inode, struct file *file)
{
  pr_debug("%s - june\n", __func__);
  return 0;
}

static int es310_dev_release(struct inode *inode, struct file *file)
{
  pr_debug("%s - june\n", __func__);
  return 0;
}

static long es310_dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    int     ret = 0;
    char    diag_ctrl = 0x00;

    if(arg!=0)
    {
        if( copy_from_user( &diag_ctrl, (void *)arg, sizeof(diag_ctrl) ) )
        {
            printk( KERN_ERR "[es310] I/O Control : copy_from_user ERROR \n" );
            return ret;
        }
    }
    pr_debug("%s : (diag_ctrl=0x%02X) - june\n", __func__, diag_ctrl);

    
    mutex_lock(&es310_dev_lock);
    switch(cmd)
    {
    case ES310_GET_ID :
        pr_debug("%s : ES310_GET_ID - june\n", __func__);
        ret = 1;
        break;

    case ES310_MIC_BIAS_IOCTL :
        pr_debug("%s : ES310_MIC_BIAS_IOCTL - june\n", __func__);
        if( es310_mic_ctrl(diag_ctrl) )
        {
            pr_debug("%s : ES310_MIC_BIAS_IOCTL fail - june\n", __func__);
            ret = -1;
            break;
        }
        pr_debug("%s : ES310_MIC_BIAS_IOCTL success - june\n", __func__);
        ret = 0;
        break;
		
	
	case ES310_MIC_SETPATH:
	{
		char mic_bias_cmd = 0x00;
		char select_mic_bias_cmd = 0x00; 

		if(diag_ctrl == 0x00) {
			es310_amp_set_device(ES310_OFF);	
		}
		else if(diag_ctrl == 0x01) {
			es310_amp_set_device(ES310_CT_VPOFF); 
			es310_mic_select_input(ES310_MIC_HANDSET); 
			es310_amp_select_output(ES310_AMP_RECIVER);

			select_mic_bias_cmd = 0x01; 
		}
		else if(diag_ctrl == 0x02) {
			es310_amp_set_device(ES310_WHS_VPOFF); 
			es310_mic_select_input(ES310_MIC_HEADSET);
			es310_amp_select_output(ES310_AMP_HEADSET);

			select_mic_bias_cmd = 0x10; 
		}
		else if(diag_ctrl == 0x03) {
			es310_amp_set_device(ES310_CT_VPOFF);	
			es310_mic_select_input(ES310_MIC_SPEAKER);
			es310_amp_select_output(ES310_AMP_HEADSET);

			select_mic_bias_cmd = 0x01; 
		}
		else if(diag_ctrl == 0x04) {
			es310_amp_set_device(ES310_WHS_VPOFF); 
			es310_mic_select_input(ES310_MIC_BACK);
			es310_amp_select_output(ES310_AMP_HEADSET);

			select_mic_bias_cmd = 0x10; 
		}
		
		else if(diag_ctrl == 0x05) {
			es310_amp_set_device(ES310_CT_VPOFF); 
			es310_mic_select_input(ES310_MIC_HANDSET);
			es310_amp_select_output(ES310_AMP_HEADSET);

			select_mic_bias_cmd = 0x01; 
		}
		
		
		es310_mic_ctrl(mic_bias_cmd);
		if(select_mic_bias_cmd != 0x00)
			es310_mic_ctrl(select_mic_bias_cmd);
	
        ret = 0;
        break;
    }
	
	
    default :
        pr_debug("%s : cmd default - june\n", __func__);
        ret = 0;
        break;
    }
    mutex_unlock(&es310_dev_lock);
    return ret;
}

static struct file_operations es310_fops = {
  .owner  = THIS_MODULE,
  .open     = es310_dev_open,
  .release  = es310_dev_release,
  .unlocked_ioctl = es310_dev_ioctl
};

struct miscdevice es310_dev = {
  .minor  = MISC_DYNAMIC_MINOR,
  .name   = "es310_dev",
  .fops   = &es310_fops,
};


static int __init es310_init(void)
{
  misc_register(&es310_dev); 
	return i2c_add_driver(&es310_i2c_driver);
}
module_init(es310_init);

static void __exit es310_exit(void)
{
	i2c_del_driver(&es310_i2c_driver);
}
module_exit(es310_exit);

MODULE_DESCRIPTION("ASoC es310 driver");
MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfonmicro.com>");
MODULE_LICENSE("GPL");
